import{_ as e,c as t,o as r,ag as o}from"./chunks/framework.ByciF0Oj.js";const n="/server/kb1.png",l="/server/kb2.png",s="/server/kb3.png",d="/server/kb4.png",k=JSON.parse('{"title":"在LangChat中配置知识库","description":"","frontmatter":{},"headers":[],"relativePath":"langchat/docs/server/knowledge.md","filePath":"langchat/docs/server/knowledge.md","lastUpdated":1738637454000}'),p={name:"langchat/docs/server/knowledge.md"};function i(c,a,h,g,_,m){return r(),t("div",null,a[0]||(a[0]=[o('<h1 id="在langchat中配置知识库" tabindex="-1">在LangChat中配置知识库 <a class="header-anchor" href="#在langchat中配置知识库" aria-label="Permalink to &quot;在LangChat中配置知识库&quot;">​</a></h1><p>首先进入到LangChat的知识库管理页面：</p><p><img src="'+n+'" alt="" loading="lazy"></p><h2 id="导入知识库" tabindex="-1">导入知识库 <a class="header-anchor" href="#导入知识库" aria-label="Permalink to &quot;导入知识库&quot;">​</a></h2><p>可以自由创建知识库，创建完成后，即可进入配置页面，可以通过两种方式：导入文档、或者录入文本数据进行向量化解析。</p><blockquote><p>为什么要向量化？简单理解就是：将文本内容转换成不同维度的有上下文关系的二进制数组数据，也就是将文本细化，可以更精确的匹配到相关联的文本关键词。</p></blockquote><h2 id="文档管理" tabindex="-1">文档管理 <a class="header-anchor" href="#文档管理" aria-label="Permalink to &quot;文档管理&quot;">​</a></h2><p>上面导入的知识库文档，可以在这里搜索到，并且可以查看文档是否已经被训练（向量化），用户可以选择重新训练（将会删除向量数据库中原始数据并重新做Embedding）</p><p><img src="'+l+'" alt="" loading="lazy"></p><h2 id="切片管理" tabindex="-1">切片管理 <a class="header-anchor" href="#切片管理" aria-label="Permalink to &quot;切片管理&quot;">​</a></h2><p>同样的，上面导入了知识库文档后，系统将通过Embedding模型向量化文档数据。</p><p><strong>为什么是切片？</strong> Embedding模型要将文档解析为向量数据，这些数据最终会存储到VectorStore向量数据库中， 而对于文档内容过多的时候会将一个文档拆分为多个部分进行向量化存储。（也有可能例如分段、分页等分割方式）。</p><p>在LangChat的切片管理页面可以轻松的查看到不同文档最终分割的切片数据集。</p><p><img src="'+s+'" alt="" loading="lazy"></p><h2 id="切片检索" tabindex="-1">切片检索 <a class="header-anchor" href="#切片检索" aria-label="Permalink to &quot;切片检索&quot;">​</a></h2><p>如果熟悉RAG系统流程的朋友应该知道，RAG实际是通过将用户问题返回到向量数据库中匹配相似的文档，并将匹配结果吐给LLM，因此LLM能够在最小的样本数据中分析出来上下文的含义并做解答。</p><p>LangChat同样提供了可视化的检索页面，通过查询某个关键词，从向量数据库中检索相似的文本，这和SQL的 <code>select * from db where keywork like &#39;xxx&#39;</code> 是类似的。</p><p><img src="'+d+'" alt="" loading="lazy"></p><p>最终使用RAG系统检索后的数据也是通过这种方式交给模型分析处理的。</p>',19)]))}const u=e(p,[["render",i]]);export{k as __pageData,u as default};

import{_ as t,c as e,o as r,ag as o}from"./chunks/framework.ByciF0Oj.js";const i="/202407191002832.png",l="/202407191003743.png",n="/202407191004287.png",p="/202407191005916.jpeg",s="/202407191006602.jpeg",c="/202407191007600.jpeg",h="/202407191037530.jpeg",_="/202407191020673.jpeg",d="/202407191021543.jpeg",g="/202407191023883.jpeg",A=JSON.parse('{"title":"LangChain如何实现RAG？","description":"","frontmatter":{},"headers":[],"relativePath":"langchat/docs/rag.md","filePath":"langchat/docs/rag.md","lastUpdated":1738637454000}'),m={name:"langchat/docs/rag.md"};function u(b,a,q,f,P,x){return r(),e("div",null,a[0]||(a[0]=[o('<h1 id="langchain如何实现rag" tabindex="-1">LangChain如何实现RAG？ <a class="header-anchor" href="#langchain如何实现rag" aria-label="Permalink to &quot;LangChain如何实现RAG？&quot;">​</a></h1><p>Baptiste Adrien分享了使用 Vercel和NextJS 开发 RAG（检索增强生成）系统，使用图例详细介绍RAG系统的设计流程，非常直观详细，对于学习大模型AIGC产品设计流程非常有帮助。</p><h2 id="_1-文档处理" tabindex="-1">1. 文档处理 <a class="header-anchor" href="#_1-文档处理" aria-label="Permalink to &quot;1. 文档处理&quot;">​</a></h2><p>开发RAG系统的第一步是准备文档，这些文档将作为RAG系统的基础输入数据。</p><p><img src="'+i+'" alt="图像" loading="lazy"></p><h2 id="_2-ocr文本提取" tabindex="-1">2. OCR文本提取 <a class="header-anchor" href="#_2-ocr文本提取" aria-label="Permalink to &quot;2. OCR文本提取&quot;">​</a></h2><p>接下来，文档由 OCR（图片转文本）模型进行处理。如果需要，该模型会提取文本。</p><p><img src="'+l+'" alt="图像" loading="lazy"></p><h2 id="_3-文本拆分" tabindex="-1">3. 文本拆分 <a class="header-anchor" href="#_3-文本拆分" aria-label="Permalink to &quot;3. 文本拆分&quot;">​</a></h2><p>文本被分成更小的、易于管理的部分。这种分块可以在后期进行更有效的处理和分析。</p><p><img src="'+n+'" alt="图像" loading="lazy"></p><h2 id="_4-文本嵌入" tabindex="-1">4. 文本嵌入 <a class="header-anchor" href="#_4-文本嵌入" aria-label="Permalink to &quot;4. 文本嵌入&quot;">​</a></h2><p>然后每个文本块都会通过嵌入模型。该模型将块转换为向量，即捕获文本语义的数字表示。</p><p><img src="'+p+'" alt="图像" loading="lazy"></p><h2 id="_5-向量存储" tabindex="-1">5. 向量存储 <a class="header-anchor" href="#_5-向量存储" aria-label="Permalink to &quot;5. 向量存储&quot;">​</a></h2><p>上一步将文本转换为向量数据库需要存储到向量数据库中（例如PgVector），该数据库允许系统根据语义相似性有效地检索相关信息。</p><p><img src="'+s+'" alt="图像" loading="lazy"></p><h2 id="_6-输入问题并检索" tabindex="-1">6. 输入问题并检索 <a class="header-anchor" href="#_6-输入问题并检索" aria-label="Permalink to &quot;6. 输入问题并检索&quot;">​</a></h2><p>用户向系统输入问题，该问题将用于从矢量数据库中检索最相关的信息（其实就是从向量库中匹配相似的数据）。</p><p><img src="'+c+'" alt="图像" loading="lazy"></p><h2 id="_7-输入嵌入" tabindex="-1">7. 输入嵌入 <a class="header-anchor" href="#_7-输入嵌入" aria-label="Permalink to &quot;7. 输入嵌入&quot;">​</a></h2><p>接下来需要将用户输入的问题转换成相同的向量纬度，只有转换成和文档相同的向量纬度，确保了问题和文本块都位于同一向量空间中，才能从向量数据库中匹配到相似的数据</p><p><img src="'+h+'" alt="图像" loading="lazy"></p><h2 id="_8-向量匹配" tabindex="-1">8. 向量匹配 <a class="header-anchor" href="#_8-向量匹配" aria-label="Permalink to &quot;8. 向量匹配&quot;">​</a></h2><p>同上，将嵌入后的问题在向量存储库中检索匹配相似的数据</p><p><img src="'+_+'" alt="图像" loading="lazy"></p><h2 id="_9-数据处理" tabindex="-1">9. 数据处理 <a class="header-anchor" href="#_9-数据处理" aria-label="Permalink to &quot;9. 数据处理&quot;">​</a></h2><p>从向量库中匹配到相似的数据后，系统将交由LLM 处理相关信息以对用户的问题制定详细的答案。</p><p><img src="'+d+'" alt="图像" loading="lazy"></p><h2 id="_10-数据呈现" tabindex="-1">10. 数据呈现 <a class="header-anchor" href="#_10-数据呈现" aria-label="Permalink to &quot;10. 数据呈现&quot;">​</a></h2><p>最终，LLM将针对用户的问题，并结合向量库中匹配到的相似的数据分析，输出最终的语义化文本内容给用户</p><p><img src="'+g+'" alt="图像" loading="lazy"></p>',32)]))}const R=t(m,[["render",u]]);export{A as __pageData,R as default};
